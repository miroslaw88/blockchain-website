// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: osdblockchain/osdblockchain/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { IndexerRange } from "./indexer";
import { Params } from "./params";
import { StorageProvider } from "./storage_provider";

export const protobufPackage = "osdblockchain.osdblockchain.v1";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

/** MsgBuyStorage is the Msg/BuyStorage request type. */
export interface MsgBuyStorage {
  /** buyer is the address that is buying the storage. */
  buyer: string;
  /** bytes is the number of bytes of storage to buy. */
  bytes: number;
  /** payment is the payment amount for the storage purchase. */
  payment: string;
  /** duration is the storage subscription duration in days. */
  duration: number;
}

/**
 * MsgBuyStorageResponse defines the response structure for executing a
 * MsgBuyStorage message.
 */
export interface MsgBuyStorageResponse {
}

/** MsgExtendStorageDuration is the Msg/ExtendStorageDuration request type. */
export interface MsgExtendStorageDuration {
  /** buyer is the address that owns the storage subscription. */
  buyer: string;
  /** duration is the number of days to extend the storage subscription duration. */
  duration: number;
  /**
   * payment is the payment amount for the duration extension.
   * The cost is calculated as: SpaceAvailable * duration * price_per_byte
   */
  payment: string;
}

/**
 * MsgExtendStorageDurationResponse defines the response structure for executing a
 * MsgExtendStorageDuration message.
 */
export interface MsgExtendStorageDurationResponse {
  /** extended_duration_days is the number of days added to the subscription duration. */
  extendedDurationDays: number;
  /** new_end_time is the new subscription end time (Unix timestamp, seconds). */
  newEndTime: number;
}

/**
 * MsgPostKey is the Msg/PostKey request type.
 * This message posts an ECIES public key for the account on-chain.
 */
export interface MsgPostKey {
  /** owner is the address that owns the ECIES public key (must match signer). */
  owner: string;
  /** ecies_public_key is the hex-encoded ECIES public key. */
  eciesPublicKey: string;
}

/**
 * MsgPostKeyResponse defines the response structure for executing a
 * MsgPostKey message.
 */
export interface MsgPostKeyResponse {
  /** success indicates whether the ECIES public key was successfully stored. */
  success: boolean;
}

/**
 * MsgDeleteKey is the Msg/DeleteKey request type.
 * This message deletes an ECIES public key entry for the account.
 */
export interface MsgDeleteKey {
  /** owner is the address that owns the ECIES public key (must match signer). */
  owner: string;
}

/**
 * MsgDeleteKeyResponse defines the response structure for executing a
 * MsgDeleteKey message.
 */
export interface MsgDeleteKeyResponse {
  /** success indicates whether the ECIES public key was successfully deleted. */
  success: boolean;
}

/**
 * Chunk represents a single chunk of a file.
 * This is used in MsgPostFile to provide chunk-level information.
 */
export interface Chunk {
  /** index is the position of the chunk in the file (0-based). */
  index: number;
  /** hash is the hash of the chunk (computed client-side). */
  hash: string;
  /** size is the size of the chunk in bytes (optional but useful). */
  size: number;
}

/**
 * MsgPostFile is the Msg/PostFile request type.
 * This message is used to post file metadata to the chain after the file has been
 * prepared (split into chunks and Merkle root computed) but before it's uploaded to storage providers.
 */
export interface MsgPostFile {
  /** owner is the address that owns the file. */
  owner: string;
  /**
   * merkle_root is the Merkle root hash of the file chunks (computed client-side).
   * This serves as the unique file identifier.
   */
  merkleRoot: string;
  /** size_bytes is the size of the file in bytes. */
  sizeBytes: number;
  /** expiration_time is when the file storage expires (Unix timestamp, seconds). */
  expirationTime: number;
  /**
   * max_proofs is the number of storage providers that should store this file.
   * Default: 3 (for redundancy)
   */
  maxProofs: number;
  /**
   * metadata is JSON metadata containing additional file information.
   * Can include: name, content_type, description, etc.
   */
  metadata: string;
  /** encrypted_file_key is the Base64 encoded encrypted key for file decryption. */
  encryptedFileKey: string;
  /** extra_data is additional arbitrary data that will be emitted in the post_file event. */
  extraData: string;
  /** chunks is the array of file chunks with their index, hash, and optional size. */
  chunks: Chunk[];
}

/**
 * MsgPostFileResponse defines the response structure for executing a
 * MsgPostFile message.
 */
export interface MsgPostFileResponse {
  /**
   * providers is the list of storage providers assigned to store this file.
   * User should choose one provider to upload to, which will then replicate to others.
   * Empty if insufficient providers are available (file added to pending queue).
   */
  providers: StorageProvider[];
  /**
   * primary_provider_index is the recommended provider index (0-based) for user to upload to.
   * User can choose any provider, but this is a suggestion (e.g., first one, or based on capacity).
   * Set to -1 if no providers are available.
   */
  primaryProviderIndex: number;
}

/**
 * MsgRegisterIndexer registers a new indexer.
 * When an indexer registers, the system automatically calculates and assigns
 * a hash prefix range based on the current number of indexers and group-based splitting.
 */
export interface MsgRegisterIndexer {
  /** indexer is the address of the indexer (must match signer). */
  indexer: string;
  /** indexer_id is a unique identifier for this indexer (e.g., "indexer_1"). */
  indexerId: string;
  /** indexer_address is the network address (e.g., "192.168.1.1:8081" or "indexer.example.com"). */
  indexerAddress: string;
}

/** MsgRegisterIndexerResponse returns the assigned range and all indexer ranges. */
export interface MsgRegisterIndexerResponse {
  /** assigned_range is the range assigned to this indexer. */
  assignedRange:
    | IndexerRange
    | undefined;
  /** all_ranges is all indexer ranges (for client caching and indexer synchronization). */
  allRanges: IndexerRange[];
}

/**
 * MsgUpdateIndexerRange updates an indexer's range (authority-only).
 * This is used for manual range adjustments or during prefix splits.
 */
export interface MsgUpdateIndexerRange {
  /** authority is the address that can update ranges (typically x/gov module). */
  authority: string;
  /** indexer_id is the indexer to update. */
  indexerId: string;
  /** new_range is the new range assignment. */
  newRange: IndexerRange | undefined;
}

/** MsgUpdateIndexerRangeResponse defines the response structure. */
export interface MsgUpdateIndexerRangeResponse {
}

/**
 * MsgDeregisterIndexer deactivates an indexer and triggers range recalculation.
 * When an indexer is deregistered, the system automatically recalculates all indexer
 * ranges based on the new active count, which may cause existing indexers to have
 * their ranges updated (expanded or moved) to maintain balanced distribution.
 */
export interface MsgDeregisterIndexer {
  /** authority is the address that can deregister indexers (typically x/gov module or the indexer itself). */
  authority: string;
  /** indexer_id is the unique identifier of the indexer to deregister. */
  indexerId: string;
}

/** MsgDeregisterIndexerResponse returns the updated ranges for all remaining active indexers. */
export interface MsgDeregisterIndexerResponse {
  /** all_ranges is all updated indexer ranges after recalculation (for client caching and indexer synchronization). */
  allRanges: IndexerRange[];
  /** total_active_indexers is the new total count of active indexers after deregistration. */
  totalActiveIndexers: number;
}

/**
 * MsgRegisterStorageProvider registers a new storage provider.
 * Storage providers store actual file data off-chain and can submit proofs to verify storage.
 */
export interface MsgRegisterStorageProvider {
  /** provider is the address of the storage provider (must match signer). */
  provider: string;
  /** provider_id is a unique identifier for this storage provider (e.g., "provider_1"). */
  providerId: string;
  /** provider_address is the network address (e.g., "192.168.1.1:8080" or "provider.example.com"). */
  providerAddress: string;
  /**
   * total_capacity_bytes is the total storage capacity advertised by this provider (in bytes).
   * This is informational and helps clients choose providers based on available capacity.
   */
  totalCapacityBytes: number;
}

/** MsgRegisterStorageProviderResponse returns the registered storage provider information. */
export interface MsgRegisterStorageProviderResponse {
  /** provider is the registered storage provider information. */
  provider: StorageProvider | undefined;
}

/**
 * MsgConfirmReplication confirms that a storage provider has successfully replicated a file.
 * This message is sent by a storage provider after it has received and stored a file via replication.
 */
export interface MsgConfirmReplication {
  /** provider is the address of the storage provider confirming replication (must match signer). */
  provider: string;
  /** provider_id is the unique identifier of the storage provider. */
  providerId: string;
  /** merkle_root is the Merkle root hash of the file that was replicated. */
  merkleRoot: string;
}

/** MsgConfirmReplicationResponse returns the result of the replication confirmation. */
export interface MsgConfirmReplicationResponse {
  /** success indicates whether the confirmation was successful. */
  success: boolean;
  /** total_assigned_providers is the total number of providers now assigned to the file. */
  totalAssignedProviders: number;
  /** removed_from_queue indicates if the file was removed from the pending queue. */
  removedFromQueue: boolean;
}

/**
 * MsgCreateDirectory is the Msg/CreateDirectory request type.
 * This message is used to create a directory for an owner.
 * Indexer nodes will listen to the emitted event and create the directory in their local storage.
 */
export interface MsgCreateDirectory {
  /** owner is the address that owns the directory. */
  owner: string;
  /**
   * path is the directory path (e.g., "/documents/folder1").
   * Must be a valid path starting with "/".
   */
  path: string;
}

/**
 * MsgCreateDirectoryResponse defines the response structure for executing a
 * MsgCreateDirectory message.
 */
export interface MsgCreateDirectoryResponse {
  /** created_at is the Unix timestamp when the directory was created (seconds). */
  createdAt: number;
}

/**
 * MsgDeleteFile is the Msg/DeleteFile request type.
 * This message is used to delete a file for an owner.
 * Indexer nodes will listen to the emitted event and delete the file from their local storage.
 */
export interface MsgDeleteFile {
  /** owner is the address that owns the file. */
  owner: string;
  /** merkle_root is the Merkle root hash of the file to delete. */
  merkleRoot: string;
}

/**
 * MsgDeleteFileResponse defines the response structure for executing a
 * MsgDeleteFile message.
 */
export interface MsgDeleteFileResponse {
  /** deleted_at is the Unix timestamp when the file was deleted (seconds). */
  deletedAt: number;
}

/**
 * MsgDeleteDirectory is the Msg/DeleteDirectory request type.
 * This message is used to delete a directory for an owner.
 * Indexer nodes will listen to the emitted event and recursively delete the directory and all its contents.
 */
export interface MsgDeleteDirectory {
  /** owner is the address that owns the directory. */
  owner: string;
  /**
   * path is the directory path to delete (e.g., "/documents/folder1").
   * Must be a valid path starting with "/".
   */
  path: string;
}

/**
 * MsgDeleteDirectoryResponse defines the response structure for executing a
 * MsgDeleteDirectory message.
 */
export interface MsgDeleteDirectoryResponse {
  /** deleted_at is the Unix timestamp when the directory was deleted (seconds). */
  deletedAt: number;
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgBuyStorage(): MsgBuyStorage {
  return { buyer: "", bytes: 0, payment: "", duration: 0 };
}

export const MsgBuyStorage: MessageFns<MsgBuyStorage> = {
  encode(message: MsgBuyStorage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buyer !== "") {
      writer.uint32(10).string(message.buyer);
    }
    if (message.bytes !== 0) {
      writer.uint32(16).int64(message.bytes);
    }
    if (message.payment !== "") {
      writer.uint32(26).string(message.payment);
    }
    if (message.duration !== 0) {
      writer.uint32(32).int64(message.duration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBuyStorage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBuyStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buyer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytes = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBuyStorage {
    return {
      buyer: isSet(object.buyer) ? globalThis.String(object.buyer) : "",
      bytes: isSet(object.bytes) ? globalThis.Number(object.bytes) : 0,
      payment: isSet(object.payment) ? globalThis.String(object.payment) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: MsgBuyStorage): unknown {
    const obj: any = {};
    if (message.buyer !== "") {
      obj.buyer = message.buyer;
    }
    if (message.bytes !== 0) {
      obj.bytes = Math.round(message.bytes);
    }
    if (message.payment !== "") {
      obj.payment = message.payment;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBuyStorage>, I>>(base?: I): MsgBuyStorage {
    return MsgBuyStorage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBuyStorage>, I>>(object: I): MsgBuyStorage {
    const message = createBaseMsgBuyStorage();
    message.buyer = object.buyer ?? "";
    message.bytes = object.bytes ?? 0;
    message.payment = object.payment ?? "";
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseMsgBuyStorageResponse(): MsgBuyStorageResponse {
  return {};
}

export const MsgBuyStorageResponse: MessageFns<MsgBuyStorageResponse> = {
  encode(_: MsgBuyStorageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBuyStorageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBuyStorageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBuyStorageResponse {
    return {};
  },

  toJSON(_: MsgBuyStorageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBuyStorageResponse>, I>>(base?: I): MsgBuyStorageResponse {
    return MsgBuyStorageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBuyStorageResponse>, I>>(_: I): MsgBuyStorageResponse {
    const message = createBaseMsgBuyStorageResponse();
    return message;
  },
};

function createBaseMsgExtendStorageDuration(): MsgExtendStorageDuration {
  return { buyer: "", duration: 0, payment: "" };
}

export const MsgExtendStorageDuration: MessageFns<MsgExtendStorageDuration> = {
  encode(message: MsgExtendStorageDuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buyer !== "") {
      writer.uint32(10).string(message.buyer);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int64(message.duration);
    }
    if (message.payment !== "") {
      writer.uint32(26).string(message.payment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgExtendStorageDuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExtendStorageDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buyer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgExtendStorageDuration {
    return {
      buyer: isSet(object.buyer) ? globalThis.String(object.buyer) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      payment: isSet(object.payment) ? globalThis.String(object.payment) : "",
    };
  },

  toJSON(message: MsgExtendStorageDuration): unknown {
    const obj: any = {};
    if (message.buyer !== "") {
      obj.buyer = message.buyer;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.payment !== "") {
      obj.payment = message.payment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgExtendStorageDuration>, I>>(base?: I): MsgExtendStorageDuration {
    return MsgExtendStorageDuration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgExtendStorageDuration>, I>>(object: I): MsgExtendStorageDuration {
    const message = createBaseMsgExtendStorageDuration();
    message.buyer = object.buyer ?? "";
    message.duration = object.duration ?? 0;
    message.payment = object.payment ?? "";
    return message;
  },
};

function createBaseMsgExtendStorageDurationResponse(): MsgExtendStorageDurationResponse {
  return { extendedDurationDays: 0, newEndTime: 0 };
}

export const MsgExtendStorageDurationResponse: MessageFns<MsgExtendStorageDurationResponse> = {
  encode(message: MsgExtendStorageDurationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.extendedDurationDays !== 0) {
      writer.uint32(8).int64(message.extendedDurationDays);
    }
    if (message.newEndTime !== 0) {
      writer.uint32(16).int64(message.newEndTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgExtendStorageDurationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgExtendStorageDurationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.extendedDurationDays = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newEndTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgExtendStorageDurationResponse {
    return {
      extendedDurationDays: isSet(object.extendedDurationDays) ? globalThis.Number(object.extendedDurationDays) : 0,
      newEndTime: isSet(object.newEndTime) ? globalThis.Number(object.newEndTime) : 0,
    };
  },

  toJSON(message: MsgExtendStorageDurationResponse): unknown {
    const obj: any = {};
    if (message.extendedDurationDays !== 0) {
      obj.extendedDurationDays = Math.round(message.extendedDurationDays);
    }
    if (message.newEndTime !== 0) {
      obj.newEndTime = Math.round(message.newEndTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgExtendStorageDurationResponse>, I>>(
    base?: I,
  ): MsgExtendStorageDurationResponse {
    return MsgExtendStorageDurationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgExtendStorageDurationResponse>, I>>(
    object: I,
  ): MsgExtendStorageDurationResponse {
    const message = createBaseMsgExtendStorageDurationResponse();
    message.extendedDurationDays = object.extendedDurationDays ?? 0;
    message.newEndTime = object.newEndTime ?? 0;
    return message;
  },
};

function createBaseMsgPostKey(): MsgPostKey {
  return { owner: "", eciesPublicKey: "" };
}

export const MsgPostKey: MessageFns<MsgPostKey> = {
  encode(message: MsgPostKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.eciesPublicKey !== "") {
      writer.uint32(18).string(message.eciesPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPostKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPostKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eciesPublicKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPostKey {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      eciesPublicKey: isSet(object.eciesPublicKey) ? globalThis.String(object.eciesPublicKey) : "",
    };
  },

  toJSON(message: MsgPostKey): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.eciesPublicKey !== "") {
      obj.eciesPublicKey = message.eciesPublicKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPostKey>, I>>(base?: I): MsgPostKey {
    return MsgPostKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPostKey>, I>>(object: I): MsgPostKey {
    const message = createBaseMsgPostKey();
    message.owner = object.owner ?? "";
    message.eciesPublicKey = object.eciesPublicKey ?? "";
    return message;
  },
};

function createBaseMsgPostKeyResponse(): MsgPostKeyResponse {
  return { success: false };
}

export const MsgPostKeyResponse: MessageFns<MsgPostKeyResponse> = {
  encode(message: MsgPostKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPostKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPostKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPostKeyResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: MsgPostKeyResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPostKeyResponse>, I>>(base?: I): MsgPostKeyResponse {
    return MsgPostKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPostKeyResponse>, I>>(object: I): MsgPostKeyResponse {
    const message = createBaseMsgPostKeyResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseMsgDeleteKey(): MsgDeleteKey {
  return { owner: "" };
}

export const MsgDeleteKey: MessageFns<MsgDeleteKey> = {
  encode(message: MsgDeleteKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteKey {
    return { owner: isSet(object.owner) ? globalThis.String(object.owner) : "" };
  },

  toJSON(message: MsgDeleteKey): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteKey>, I>>(base?: I): MsgDeleteKey {
    return MsgDeleteKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteKey>, I>>(object: I): MsgDeleteKey {
    const message = createBaseMsgDeleteKey();
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseMsgDeleteKeyResponse(): MsgDeleteKeyResponse {
  return { success: false };
}

export const MsgDeleteKeyResponse: MessageFns<MsgDeleteKeyResponse> = {
  encode(message: MsgDeleteKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteKeyResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: MsgDeleteKeyResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteKeyResponse>, I>>(base?: I): MsgDeleteKeyResponse {
    return MsgDeleteKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteKeyResponse>, I>>(object: I): MsgDeleteKeyResponse {
    const message = createBaseMsgDeleteKeyResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseChunk(): Chunk {
  return { index: 0, hash: "", size: 0 };
}

export const Chunk: MessageFns<Chunk> = {
  encode(message: Chunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int64(message.index);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.size !== 0) {
      writer.uint32(24).int64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chunk {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: Chunk): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chunk>, I>>(base?: I): Chunk {
    return Chunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chunk>, I>>(object: I): Chunk {
    const message = createBaseChunk();
    message.index = object.index ?? 0;
    message.hash = object.hash ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseMsgPostFile(): MsgPostFile {
  return {
    owner: "",
    merkleRoot: "",
    sizeBytes: 0,
    expirationTime: 0,
    maxProofs: 0,
    metadata: "",
    encryptedFileKey: "",
    extraData: "",
    chunks: [],
  };
}

export const MsgPostFile: MessageFns<MsgPostFile> = {
  encode(message: MsgPostFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.merkleRoot !== "") {
      writer.uint32(18).string(message.merkleRoot);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(24).int64(message.sizeBytes);
    }
    if (message.expirationTime !== 0) {
      writer.uint32(32).int64(message.expirationTime);
    }
    if (message.maxProofs !== 0) {
      writer.uint32(40).int64(message.maxProofs);
    }
    if (message.metadata !== "") {
      writer.uint32(50).string(message.metadata);
    }
    if (message.encryptedFileKey !== "") {
      writer.uint32(58).string(message.encryptedFileKey);
    }
    if (message.extraData !== "") {
      writer.uint32(66).string(message.extraData);
    }
    for (const v of message.chunks) {
      Chunk.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPostFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPostFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sizeBytes = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expirationTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxProofs = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.encryptedFileKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.extraData = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.chunks.push(Chunk.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPostFile {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "",
      sizeBytes: isSet(object.sizeBytes) ? globalThis.Number(object.sizeBytes) : 0,
      expirationTime: isSet(object.expirationTime) ? globalThis.Number(object.expirationTime) : 0,
      maxProofs: isSet(object.maxProofs) ? globalThis.Number(object.maxProofs) : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      encryptedFileKey: isSet(object.encryptedFileKey) ? globalThis.String(object.encryptedFileKey) : "",
      extraData: isSet(object.extraData) ? globalThis.String(object.extraData) : "",
      chunks: globalThis.Array.isArray(object?.chunks) ? object.chunks.map((e: any) => Chunk.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgPostFile): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.expirationTime !== 0) {
      obj.expirationTime = Math.round(message.expirationTime);
    }
    if (message.maxProofs !== 0) {
      obj.maxProofs = Math.round(message.maxProofs);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.encryptedFileKey !== "") {
      obj.encryptedFileKey = message.encryptedFileKey;
    }
    if (message.extraData !== "") {
      obj.extraData = message.extraData;
    }
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => Chunk.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPostFile>, I>>(base?: I): MsgPostFile {
    return MsgPostFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPostFile>, I>>(object: I): MsgPostFile {
    const message = createBaseMsgPostFile();
    message.owner = object.owner ?? "";
    message.merkleRoot = object.merkleRoot ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.expirationTime = object.expirationTime ?? 0;
    message.maxProofs = object.maxProofs ?? 0;
    message.metadata = object.metadata ?? "";
    message.encryptedFileKey = object.encryptedFileKey ?? "";
    message.extraData = object.extraData ?? "";
    message.chunks = object.chunks?.map((e) => Chunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgPostFileResponse(): MsgPostFileResponse {
  return { providers: [], primaryProviderIndex: 0 };
}

export const MsgPostFileResponse: MessageFns<MsgPostFileResponse> = {
  encode(message: MsgPostFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.providers) {
      StorageProvider.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.primaryProviderIndex !== 0) {
      writer.uint32(16).int32(message.primaryProviderIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPostFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPostFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providers.push(StorageProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.primaryProviderIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPostFileResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => StorageProvider.fromJSON(e))
        : [],
      primaryProviderIndex: isSet(object.primaryProviderIndex) ? globalThis.Number(object.primaryProviderIndex) : 0,
    };
  },

  toJSON(message: MsgPostFileResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => StorageProvider.toJSON(e));
    }
    if (message.primaryProviderIndex !== 0) {
      obj.primaryProviderIndex = Math.round(message.primaryProviderIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPostFileResponse>, I>>(base?: I): MsgPostFileResponse {
    return MsgPostFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPostFileResponse>, I>>(object: I): MsgPostFileResponse {
    const message = createBaseMsgPostFileResponse();
    message.providers = object.providers?.map((e) => StorageProvider.fromPartial(e)) || [];
    message.primaryProviderIndex = object.primaryProviderIndex ?? 0;
    return message;
  },
};

function createBaseMsgRegisterIndexer(): MsgRegisterIndexer {
  return { indexer: "", indexerId: "", indexerAddress: "" };
}

export const MsgRegisterIndexer: MessageFns<MsgRegisterIndexer> = {
  encode(message: MsgRegisterIndexer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexer !== "") {
      writer.uint32(10).string(message.indexer);
    }
    if (message.indexerId !== "") {
      writer.uint32(18).string(message.indexerId);
    }
    if (message.indexerAddress !== "") {
      writer.uint32(26).string(message.indexerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterIndexer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterIndexer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indexerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.indexerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterIndexer {
    return {
      indexer: isSet(object.indexer) ? globalThis.String(object.indexer) : "",
      indexerId: isSet(object.indexerId) ? globalThis.String(object.indexerId) : "",
      indexerAddress: isSet(object.indexerAddress) ? globalThis.String(object.indexerAddress) : "",
    };
  },

  toJSON(message: MsgRegisterIndexer): unknown {
    const obj: any = {};
    if (message.indexer !== "") {
      obj.indexer = message.indexer;
    }
    if (message.indexerId !== "") {
      obj.indexerId = message.indexerId;
    }
    if (message.indexerAddress !== "") {
      obj.indexerAddress = message.indexerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterIndexer>, I>>(base?: I): MsgRegisterIndexer {
    return MsgRegisterIndexer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterIndexer>, I>>(object: I): MsgRegisterIndexer {
    const message = createBaseMsgRegisterIndexer();
    message.indexer = object.indexer ?? "";
    message.indexerId = object.indexerId ?? "";
    message.indexerAddress = object.indexerAddress ?? "";
    return message;
  },
};

function createBaseMsgRegisterIndexerResponse(): MsgRegisterIndexerResponse {
  return { assignedRange: undefined, allRanges: [] };
}

export const MsgRegisterIndexerResponse: MessageFns<MsgRegisterIndexerResponse> = {
  encode(message: MsgRegisterIndexerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assignedRange !== undefined) {
      IndexerRange.encode(message.assignedRange, writer.uint32(10).fork()).join();
    }
    for (const v of message.allRanges) {
      IndexerRange.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterIndexerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterIndexerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assignedRange = IndexerRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allRanges.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterIndexerResponse {
    return {
      assignedRange: isSet(object.assignedRange) ? IndexerRange.fromJSON(object.assignedRange) : undefined,
      allRanges: globalThis.Array.isArray(object?.allRanges)
        ? object.allRanges.map((e: any) => IndexerRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgRegisterIndexerResponse): unknown {
    const obj: any = {};
    if (message.assignedRange !== undefined) {
      obj.assignedRange = IndexerRange.toJSON(message.assignedRange);
    }
    if (message.allRanges?.length) {
      obj.allRanges = message.allRanges.map((e) => IndexerRange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterIndexerResponse>, I>>(base?: I): MsgRegisterIndexerResponse {
    return MsgRegisterIndexerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterIndexerResponse>, I>>(object: I): MsgRegisterIndexerResponse {
    const message = createBaseMsgRegisterIndexerResponse();
    message.assignedRange = (object.assignedRange !== undefined && object.assignedRange !== null)
      ? IndexerRange.fromPartial(object.assignedRange)
      : undefined;
    message.allRanges = object.allRanges?.map((e) => IndexerRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgUpdateIndexerRange(): MsgUpdateIndexerRange {
  return { authority: "", indexerId: "", newRange: undefined };
}

export const MsgUpdateIndexerRange: MessageFns<MsgUpdateIndexerRange> = {
  encode(message: MsgUpdateIndexerRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.indexerId !== "") {
      writer.uint32(18).string(message.indexerId);
    }
    if (message.newRange !== undefined) {
      IndexerRange.encode(message.newRange, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIndexerRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIndexerRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indexerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newRange = IndexerRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateIndexerRange {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      indexerId: isSet(object.indexerId) ? globalThis.String(object.indexerId) : "",
      newRange: isSet(object.newRange) ? IndexerRange.fromJSON(object.newRange) : undefined,
    };
  },

  toJSON(message: MsgUpdateIndexerRange): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.indexerId !== "") {
      obj.indexerId = message.indexerId;
    }
    if (message.newRange !== undefined) {
      obj.newRange = IndexerRange.toJSON(message.newRange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateIndexerRange>, I>>(base?: I): MsgUpdateIndexerRange {
    return MsgUpdateIndexerRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateIndexerRange>, I>>(object: I): MsgUpdateIndexerRange {
    const message = createBaseMsgUpdateIndexerRange();
    message.authority = object.authority ?? "";
    message.indexerId = object.indexerId ?? "";
    message.newRange = (object.newRange !== undefined && object.newRange !== null)
      ? IndexerRange.fromPartial(object.newRange)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateIndexerRangeResponse(): MsgUpdateIndexerRangeResponse {
  return {};
}

export const MsgUpdateIndexerRangeResponse: MessageFns<MsgUpdateIndexerRangeResponse> = {
  encode(_: MsgUpdateIndexerRangeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateIndexerRangeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateIndexerRangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateIndexerRangeResponse {
    return {};
  },

  toJSON(_: MsgUpdateIndexerRangeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateIndexerRangeResponse>, I>>(base?: I): MsgUpdateIndexerRangeResponse {
    return MsgUpdateIndexerRangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateIndexerRangeResponse>, I>>(_: I): MsgUpdateIndexerRangeResponse {
    const message = createBaseMsgUpdateIndexerRangeResponse();
    return message;
  },
};

function createBaseMsgDeregisterIndexer(): MsgDeregisterIndexer {
  return { authority: "", indexerId: "" };
}

export const MsgDeregisterIndexer: MessageFns<MsgDeregisterIndexer> = {
  encode(message: MsgDeregisterIndexer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.indexerId !== "") {
      writer.uint32(18).string(message.indexerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeregisterIndexer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeregisterIndexer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indexerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeregisterIndexer {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      indexerId: isSet(object.indexerId) ? globalThis.String(object.indexerId) : "",
    };
  },

  toJSON(message: MsgDeregisterIndexer): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.indexerId !== "") {
      obj.indexerId = message.indexerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeregisterIndexer>, I>>(base?: I): MsgDeregisterIndexer {
    return MsgDeregisterIndexer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeregisterIndexer>, I>>(object: I): MsgDeregisterIndexer {
    const message = createBaseMsgDeregisterIndexer();
    message.authority = object.authority ?? "";
    message.indexerId = object.indexerId ?? "";
    return message;
  },
};

function createBaseMsgDeregisterIndexerResponse(): MsgDeregisterIndexerResponse {
  return { allRanges: [], totalActiveIndexers: 0 };
}

export const MsgDeregisterIndexerResponse: MessageFns<MsgDeregisterIndexerResponse> = {
  encode(message: MsgDeregisterIndexerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allRanges) {
      IndexerRange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalActiveIndexers !== 0) {
      writer.uint32(16).int64(message.totalActiveIndexers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeregisterIndexerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeregisterIndexerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allRanges.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalActiveIndexers = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeregisterIndexerResponse {
    return {
      allRanges: globalThis.Array.isArray(object?.allRanges)
        ? object.allRanges.map((e: any) => IndexerRange.fromJSON(e))
        : [],
      totalActiveIndexers: isSet(object.totalActiveIndexers) ? globalThis.Number(object.totalActiveIndexers) : 0,
    };
  },

  toJSON(message: MsgDeregisterIndexerResponse): unknown {
    const obj: any = {};
    if (message.allRanges?.length) {
      obj.allRanges = message.allRanges.map((e) => IndexerRange.toJSON(e));
    }
    if (message.totalActiveIndexers !== 0) {
      obj.totalActiveIndexers = Math.round(message.totalActiveIndexers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeregisterIndexerResponse>, I>>(base?: I): MsgDeregisterIndexerResponse {
    return MsgDeregisterIndexerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeregisterIndexerResponse>, I>>(object: I): MsgDeregisterIndexerResponse {
    const message = createBaseMsgDeregisterIndexerResponse();
    message.allRanges = object.allRanges?.map((e) => IndexerRange.fromPartial(e)) || [];
    message.totalActiveIndexers = object.totalActiveIndexers ?? 0;
    return message;
  },
};

function createBaseMsgRegisterStorageProvider(): MsgRegisterStorageProvider {
  return { provider: "", providerId: "", providerAddress: "", totalCapacityBytes: 0 };
}

export const MsgRegisterStorageProvider: MessageFns<MsgRegisterStorageProvider> = {
  encode(message: MsgRegisterStorageProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(26).string(message.providerAddress);
    }
    if (message.totalCapacityBytes !== 0) {
      writer.uint32(32).int64(message.totalCapacityBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterStorageProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterStorageProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalCapacityBytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterStorageProvider {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      providerAddress: isSet(object.providerAddress) ? globalThis.String(object.providerAddress) : "",
      totalCapacityBytes: isSet(object.totalCapacityBytes) ? globalThis.Number(object.totalCapacityBytes) : 0,
    };
  },

  toJSON(message: MsgRegisterStorageProvider): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.providerAddress !== "") {
      obj.providerAddress = message.providerAddress;
    }
    if (message.totalCapacityBytes !== 0) {
      obj.totalCapacityBytes = Math.round(message.totalCapacityBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterStorageProvider>, I>>(base?: I): MsgRegisterStorageProvider {
    return MsgRegisterStorageProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterStorageProvider>, I>>(object: I): MsgRegisterStorageProvider {
    const message = createBaseMsgRegisterStorageProvider();
    message.provider = object.provider ?? "";
    message.providerId = object.providerId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.totalCapacityBytes = object.totalCapacityBytes ?? 0;
    return message;
  },
};

function createBaseMsgRegisterStorageProviderResponse(): MsgRegisterStorageProviderResponse {
  return { provider: undefined };
}

export const MsgRegisterStorageProviderResponse: MessageFns<MsgRegisterStorageProviderResponse> = {
  encode(message: MsgRegisterStorageProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== undefined) {
      StorageProvider.encode(message.provider, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterStorageProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterStorageProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = StorageProvider.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterStorageProviderResponse {
    return { provider: isSet(object.provider) ? StorageProvider.fromJSON(object.provider) : undefined };
  },

  toJSON(message: MsgRegisterStorageProviderResponse): unknown {
    const obj: any = {};
    if (message.provider !== undefined) {
      obj.provider = StorageProvider.toJSON(message.provider);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterStorageProviderResponse>, I>>(
    base?: I,
  ): MsgRegisterStorageProviderResponse {
    return MsgRegisterStorageProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterStorageProviderResponse>, I>>(
    object: I,
  ): MsgRegisterStorageProviderResponse {
    const message = createBaseMsgRegisterStorageProviderResponse();
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? StorageProvider.fromPartial(object.provider)
      : undefined;
    return message;
  },
};

function createBaseMsgConfirmReplication(): MsgConfirmReplication {
  return { provider: "", providerId: "", merkleRoot: "" };
}

export const MsgConfirmReplication: MessageFns<MsgConfirmReplication> = {
  encode(message: MsgConfirmReplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.merkleRoot !== "") {
      writer.uint32(26).string(message.merkleRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConfirmReplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmReplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConfirmReplication {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "",
    };
  },

  toJSON(message: MsgConfirmReplication): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmReplication>, I>>(base?: I): MsgConfirmReplication {
    return MsgConfirmReplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmReplication>, I>>(object: I): MsgConfirmReplication {
    const message = createBaseMsgConfirmReplication();
    message.provider = object.provider ?? "";
    message.providerId = object.providerId ?? "";
    message.merkleRoot = object.merkleRoot ?? "";
    return message;
  },
};

function createBaseMsgConfirmReplicationResponse(): MsgConfirmReplicationResponse {
  return { success: false, totalAssignedProviders: 0, removedFromQueue: false };
}

export const MsgConfirmReplicationResponse: MessageFns<MsgConfirmReplicationResponse> = {
  encode(message: MsgConfirmReplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.totalAssignedProviders !== 0) {
      writer.uint32(16).int64(message.totalAssignedProviders);
    }
    if (message.removedFromQueue !== false) {
      writer.uint32(24).bool(message.removedFromQueue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgConfirmReplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmReplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalAssignedProviders = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.removedFromQueue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConfirmReplicationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      totalAssignedProviders: isSet(object.totalAssignedProviders)
        ? globalThis.Number(object.totalAssignedProviders)
        : 0,
      removedFromQueue: isSet(object.removedFromQueue) ? globalThis.Boolean(object.removedFromQueue) : false,
    };
  },

  toJSON(message: MsgConfirmReplicationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.totalAssignedProviders !== 0) {
      obj.totalAssignedProviders = Math.round(message.totalAssignedProviders);
    }
    if (message.removedFromQueue !== false) {
      obj.removedFromQueue = message.removedFromQueue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmReplicationResponse>, I>>(base?: I): MsgConfirmReplicationResponse {
    return MsgConfirmReplicationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmReplicationResponse>, I>>(
    object: I,
  ): MsgConfirmReplicationResponse {
    const message = createBaseMsgConfirmReplicationResponse();
    message.success = object.success ?? false;
    message.totalAssignedProviders = object.totalAssignedProviders ?? 0;
    message.removedFromQueue = object.removedFromQueue ?? false;
    return message;
  },
};

function createBaseMsgCreateDirectory(): MsgCreateDirectory {
  return { owner: "", path: "" };
}

export const MsgCreateDirectory: MessageFns<MsgCreateDirectory> = {
  encode(message: MsgCreateDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDirectory {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: MsgCreateDirectory): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateDirectory>, I>>(base?: I): MsgCreateDirectory {
    return MsgCreateDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateDirectory>, I>>(object: I): MsgCreateDirectory {
    const message = createBaseMsgCreateDirectory();
    message.owner = object.owner ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseMsgCreateDirectoryResponse(): MsgCreateDirectoryResponse {
  return { createdAt: 0 };
}

export const MsgCreateDirectoryResponse: MessageFns<MsgCreateDirectoryResponse> = {
  encode(message: MsgCreateDirectoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdAt !== 0) {
      writer.uint32(8).int64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateDirectoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateDirectoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateDirectoryResponse {
    return { createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0 };
  },

  toJSON(message: MsgCreateDirectoryResponse): unknown {
    const obj: any = {};
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateDirectoryResponse>, I>>(base?: I): MsgCreateDirectoryResponse {
    return MsgCreateDirectoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateDirectoryResponse>, I>>(object: I): MsgCreateDirectoryResponse {
    const message = createBaseMsgCreateDirectoryResponse();
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseMsgDeleteFile(): MsgDeleteFile {
  return { owner: "", merkleRoot: "" };
}

export const MsgDeleteFile: MessageFns<MsgDeleteFile> = {
  encode(message: MsgDeleteFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.merkleRoot !== "") {
      writer.uint32(18).string(message.merkleRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteFile {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "",
    };
  },

  toJSON(message: MsgDeleteFile): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFile>, I>>(base?: I): MsgDeleteFile {
    return MsgDeleteFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFile>, I>>(object: I): MsgDeleteFile {
    const message = createBaseMsgDeleteFile();
    message.owner = object.owner ?? "";
    message.merkleRoot = object.merkleRoot ?? "";
    return message;
  },
};

function createBaseMsgDeleteFileResponse(): MsgDeleteFileResponse {
  return { deletedAt: 0 };
}

export const MsgDeleteFileResponse: MessageFns<MsgDeleteFileResponse> = {
  encode(message: MsgDeleteFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deletedAt !== 0) {
      writer.uint32(8).int64(message.deletedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deletedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteFileResponse {
    return { deletedAt: isSet(object.deletedAt) ? globalThis.Number(object.deletedAt) : 0 };
  },

  toJSON(message: MsgDeleteFileResponse): unknown {
    const obj: any = {};
    if (message.deletedAt !== 0) {
      obj.deletedAt = Math.round(message.deletedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFileResponse>, I>>(base?: I): MsgDeleteFileResponse {
    return MsgDeleteFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFileResponse>, I>>(object: I): MsgDeleteFileResponse {
    const message = createBaseMsgDeleteFileResponse();
    message.deletedAt = object.deletedAt ?? 0;
    return message;
  },
};

function createBaseMsgDeleteDirectory(): MsgDeleteDirectory {
  return { owner: "", path: "" };
}

export const MsgDeleteDirectory: MessageFns<MsgDeleteDirectory> = {
  encode(message: MsgDeleteDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteDirectory {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: MsgDeleteDirectory): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteDirectory>, I>>(base?: I): MsgDeleteDirectory {
    return MsgDeleteDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteDirectory>, I>>(object: I): MsgDeleteDirectory {
    const message = createBaseMsgDeleteDirectory();
    message.owner = object.owner ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseMsgDeleteDirectoryResponse(): MsgDeleteDirectoryResponse {
  return { deletedAt: 0 };
}

export const MsgDeleteDirectoryResponse: MessageFns<MsgDeleteDirectoryResponse> = {
  encode(message: MsgDeleteDirectoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deletedAt !== 0) {
      writer.uint32(8).int64(message.deletedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteDirectoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteDirectoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deletedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteDirectoryResponse {
    return { deletedAt: isSet(object.deletedAt) ? globalThis.Number(object.deletedAt) : 0 };
  },

  toJSON(message: MsgDeleteDirectoryResponse): unknown {
    const obj: any = {};
    if (message.deletedAt !== 0) {
      obj.deletedAt = Math.round(message.deletedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteDirectoryResponse>, I>>(base?: I): MsgDeleteDirectoryResponse {
    return MsgDeleteDirectoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteDirectoryResponse>, I>>(object: I): MsgDeleteDirectoryResponse {
    const message = createBaseMsgDeleteDirectoryResponse();
    message.deletedAt = object.deletedAt ?? 0;
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  /** BuyStorage defines a message for buying storage. */
  BuyStorage(request: MsgBuyStorage): Promise<MsgBuyStorageResponse>;
  /**
   * ExtendStorageDuration defines a message for extending storage subscription duration
   * based on the storage amount purchased.
   */
  ExtendStorageDuration(request: MsgExtendStorageDuration): Promise<MsgExtendStorageDurationResponse>;
  /**
   * PostKey posts an ECIES public key for the account on-chain.
   * This public key is used for encrypting the account's symmetric key.
   */
  PostKey(request: MsgPostKey): Promise<MsgPostKeyResponse>;
  /**
   * DeleteKey deletes an ECIES public key entry for the account.
   * This removes the stored ECIES public key from the chain.
   */
  DeleteKey(request: MsgDeleteKey): Promise<MsgDeleteKeyResponse>;
  /** PostFile defines a message for posting file metadata to the chain. */
  PostFile(request: MsgPostFile): Promise<MsgPostFileResponse>;
  /** RegisterIndexer registers a new indexer and assigns it a hash prefix range. */
  RegisterIndexer(request: MsgRegisterIndexer): Promise<MsgRegisterIndexerResponse>;
  /** UpdateIndexerRange updates an indexer's assigned range (authority-only). */
  UpdateIndexerRange(request: MsgUpdateIndexerRange): Promise<MsgUpdateIndexerRangeResponse>;
  /**
   * DeregisterIndexer deactivates an indexer and recalculates ranges for all remaining active indexers.
   * When an indexer is deregistered, the system automatically recalculates all indexer
   * ranges based on the new active count, redistributing the workload among remaining indexers.
   */
  DeregisterIndexer(request: MsgDeregisterIndexer): Promise<MsgDeregisterIndexerResponse>;
  /**
   * RegisterStorageProvider registers a new storage provider.
   * Storage providers store actual file data off-chain and can submit proofs to verify storage.
   */
  RegisterStorageProvider(request: MsgRegisterStorageProvider): Promise<MsgRegisterStorageProviderResponse>;
  /**
   * ConfirmReplication confirms that a storage provider has successfully replicated a file.
   * This adds the provider to the file's assigned providers list and removes the file from
   * the pending queue if enough providers are assigned.
   */
  ConfirmReplication(request: MsgConfirmReplication): Promise<MsgConfirmReplicationResponse>;
  /**
   * CreateDirectory creates a directory for an owner.
   * Indexer nodes will listen to this event and create the directory in their local storage.
   */
  CreateDirectory(request: MsgCreateDirectory): Promise<MsgCreateDirectoryResponse>;
  /**
   * DeleteFile deletes a file for an owner.
   * Indexer nodes will listen to this event and delete the file from their local storage.
   */
  DeleteFile(request: MsgDeleteFile): Promise<MsgDeleteFileResponse>;
  /**
   * DeleteDirectory deletes a directory for an owner.
   * Indexer nodes will listen to this event and recursively delete the directory and all its contents.
   */
  DeleteDirectory(request: MsgDeleteDirectory): Promise<MsgDeleteDirectoryResponse>;
}

export const MsgServiceName = "osdblockchain.osdblockchain.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.BuyStorage = this.BuyStorage.bind(this);
    this.ExtendStorageDuration = this.ExtendStorageDuration.bind(this);
    this.PostKey = this.PostKey.bind(this);
    this.DeleteKey = this.DeleteKey.bind(this);
    this.PostFile = this.PostFile.bind(this);
    this.RegisterIndexer = this.RegisterIndexer.bind(this);
    this.UpdateIndexerRange = this.UpdateIndexerRange.bind(this);
    this.DeregisterIndexer = this.DeregisterIndexer.bind(this);
    this.RegisterStorageProvider = this.RegisterStorageProvider.bind(this);
    this.ConfirmReplication = this.ConfirmReplication.bind(this);
    this.CreateDirectory = this.CreateDirectory.bind(this);
    this.DeleteFile = this.DeleteFile.bind(this);
    this.DeleteDirectory = this.DeleteDirectory.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  BuyStorage(request: MsgBuyStorage): Promise<MsgBuyStorageResponse> {
    const data = MsgBuyStorage.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuyStorage", data);
    return promise.then((data) => MsgBuyStorageResponse.decode(new BinaryReader(data)));
  }

  ExtendStorageDuration(request: MsgExtendStorageDuration): Promise<MsgExtendStorageDurationResponse> {
    const data = MsgExtendStorageDuration.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExtendStorageDuration", data);
    return promise.then((data) => MsgExtendStorageDurationResponse.decode(new BinaryReader(data)));
  }

  PostKey(request: MsgPostKey): Promise<MsgPostKeyResponse> {
    const data = MsgPostKey.encode(request).finish();
    const promise = this.rpc.request(this.service, "PostKey", data);
    return promise.then((data) => MsgPostKeyResponse.decode(new BinaryReader(data)));
  }

  DeleteKey(request: MsgDeleteKey): Promise<MsgDeleteKeyResponse> {
    const data = MsgDeleteKey.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteKey", data);
    return promise.then((data) => MsgDeleteKeyResponse.decode(new BinaryReader(data)));
  }

  PostFile(request: MsgPostFile): Promise<MsgPostFileResponse> {
    const data = MsgPostFile.encode(request).finish();
    const promise = this.rpc.request(this.service, "PostFile", data);
    return promise.then((data) => MsgPostFileResponse.decode(new BinaryReader(data)));
  }

  RegisterIndexer(request: MsgRegisterIndexer): Promise<MsgRegisterIndexerResponse> {
    const data = MsgRegisterIndexer.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterIndexer", data);
    return promise.then((data) => MsgRegisterIndexerResponse.decode(new BinaryReader(data)));
  }

  UpdateIndexerRange(request: MsgUpdateIndexerRange): Promise<MsgUpdateIndexerRangeResponse> {
    const data = MsgUpdateIndexerRange.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateIndexerRange", data);
    return promise.then((data) => MsgUpdateIndexerRangeResponse.decode(new BinaryReader(data)));
  }

  DeregisterIndexer(request: MsgDeregisterIndexer): Promise<MsgDeregisterIndexerResponse> {
    const data = MsgDeregisterIndexer.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeregisterIndexer", data);
    return promise.then((data) => MsgDeregisterIndexerResponse.decode(new BinaryReader(data)));
  }

  RegisterStorageProvider(request: MsgRegisterStorageProvider): Promise<MsgRegisterStorageProviderResponse> {
    const data = MsgRegisterStorageProvider.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterStorageProvider", data);
    return promise.then((data) => MsgRegisterStorageProviderResponse.decode(new BinaryReader(data)));
  }

  ConfirmReplication(request: MsgConfirmReplication): Promise<MsgConfirmReplicationResponse> {
    const data = MsgConfirmReplication.encode(request).finish();
    const promise = this.rpc.request(this.service, "ConfirmReplication", data);
    return promise.then((data) => MsgConfirmReplicationResponse.decode(new BinaryReader(data)));
  }

  CreateDirectory(request: MsgCreateDirectory): Promise<MsgCreateDirectoryResponse> {
    const data = MsgCreateDirectory.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateDirectory", data);
    return promise.then((data) => MsgCreateDirectoryResponse.decode(new BinaryReader(data)));
  }

  DeleteFile(request: MsgDeleteFile): Promise<MsgDeleteFileResponse> {
    const data = MsgDeleteFile.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteFile", data);
    return promise.then((data) => MsgDeleteFileResponse.decode(new BinaryReader(data)));
  }

  DeleteDirectory(request: MsgDeleteDirectory): Promise<MsgDeleteDirectoryResponse> {
    const data = MsgDeleteDirectory.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteDirectory", data);
    return promise.then((data) => MsgDeleteDirectoryResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
