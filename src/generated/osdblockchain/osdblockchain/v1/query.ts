// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: osdblockchain/osdblockchain/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { FileMetadata } from "./file_metadata";
import { IndexerRange, PrefixLoad } from "./indexer";
import { Params } from "./params";
import { StorageProvider } from "./storage_provider";

export const protobufPackage = "osdblockchain.osdblockchain.v1";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/** QueryAccountStorageRequest is request type for the Query/AccountStorage RPC method. */
export interface QueryAccountStorageRequest {
  /** address is the account address to query storage for. */
  address: string;
}

/** SubscriptionInfo provides summary information about a storage subscription. */
export interface SubscriptionInfo {
  /** id is the subscription ID. */
  id: string;
  /** storage_bytes is the storage capacity in bytes for this subscription. */
  storageBytes: number;
  /** start_time is when the subscription becomes active (Unix timestamp, seconds). */
  startTime: number;
  /** end_time is when the subscription expires (Unix timestamp, seconds). */
  endTime: number;
  /** duration_seconds is the total duration of the subscription in seconds. */
  durationSeconds: number;
  /** remaining_seconds is the remaining time until expiration (0 if expired). */
  remainingSeconds: number;
  /** is_active indicates if the subscription is currently active. */
  isActive: boolean;
}

/** QueryAccountStorageResponse is response type for the Query/AccountStorage RPC method. */
export interface QueryAccountStorageResponse {
  /** address is the account address that was queried. */
  address: string;
  /**
   * subscription is the single subscription for this account (null if no subscription exists).
   * Each account can have at most one subscription. Buying more storage or extending duration
   * updates the existing subscription rather than creating a new one.
   * Storage size can be derived from subscription.storage_bytes.
   */
  subscription: SubscriptionInfo | undefined;
}

/** QueryAccountKeyRequest is request type for the Query/AccountKey RPC method. */
export interface QueryAccountKeyRequest {
  /** address is the account address to query the encrypted key for. */
  address: string;
}

/** QueryAccountKeyResponse is response type for the Query/AccountKey RPC method. */
export interface QueryAccountKeyResponse {
  /** encrypted_account_key is the Base64 encoded encrypted symmetric key. */
  encryptedAccountKey: string;
}

/** QueryFileRequest is request type for the Query/File RPC method. */
export interface QueryFileRequest {
  /** merkle_root is the Merkle root hash of the file to query. */
  merkleRoot: string;
}

/** QueryFileResponse is response type for the Query/File RPC method. */
export interface QueryFileResponse {
  /** file is the file metadata. */
  file: FileMetadata | undefined;
}

/** QueryFilesByProviderRequest is request type for the Query/FilesByProvider RPC method. */
export interface QueryFilesByProviderRequest {
  /** provider is the address of the storage provider. */
  provider: string;
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** QueryFilesByProviderResponse is response type for the Query/FilesByProvider RPC method. */
export interface QueryFilesByProviderResponse {
  /** files are the file metadata entries. */
  files: FileMetadata[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryIndexerRangeRequest is request type for the Query/IndexerRange RPC method. */
export interface QueryIndexerRangeRequest {
  /** indexer_id is the unique identifier of the indexer. */
  indexerId: string;
}

/** QueryIndexerRangeResponse is response type for the Query/IndexerRange RPC method. */
export interface QueryIndexerRangeResponse {
  /** range is the hash prefix range assigned to the indexer. */
  range: IndexerRange | undefined;
}

/** QueryIndexerRangesRequest is request type for the Query/IndexerRanges RPC method. */
export interface QueryIndexerRangesRequest {
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** QueryIndexerRangesResponse is response type for the Query/IndexerRanges RPC method. */
export interface QueryIndexerRangesResponse {
  /** ranges are all indexer ranges. */
  ranges: IndexerRange[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryActiveIndexersRequest is request type for the Query/ActiveIndexers RPC method. */
export interface QueryActiveIndexersRequest {
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** QueryActiveIndexersResponse is response type for the Query/ActiveIndexers RPC method. */
export interface QueryActiveIndexersResponse {
  /** indexers are all currently active indexers. */
  indexers: IndexerRange[];
  /** total_count is the total number of active indexers. */
  totalCount: number;
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryIndexersForFileRequest is request type for the Query/IndexersForFile RPC method. */
export interface QueryIndexersForFileRequest {
  /** merkle_root is the file hash to find indexers for. */
  merkleRoot: string;
}

/** QueryIndexersForFileResponse is response type for the Query/IndexersForFile RPC method. */
export interface QueryIndexersForFileResponse {
  /** indexers are the indexers that handle this file hash. */
  indexers: IndexerRange[];
}

/** QueryPrefixLoadRequest is request type for the Query/PrefixLoad RPC method. */
export interface QueryPrefixLoadRequest {
  /** prefix is the hash prefix to query (e.g., "AB"). */
  prefix: string;
  /** depth is the prefix depth (number of hex digits, e.g., 2, 4, 6). */
  depth: number;
}

/** QueryPrefixLoadResponse is response type for the Query/PrefixLoad RPC method. */
export interface QueryPrefixLoadResponse {
  /** load is the prefix load information. */
  load: PrefixLoad | undefined;
}

/** QueryPrefixLoadsRequest is request type for the Query/PrefixLoads RPC method. */
export interface QueryPrefixLoadsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination: PageRequest | undefined;
}

/** QueryPrefixLoadsResponse is response type for the Query/PrefixLoads RPC method. */
export interface QueryPrefixLoadsResponse {
  /** loads are all prefix loads. */
  loads: PrefixLoad[];
  /** pagination defines the pagination in the response. */
  pagination: PageResponse | undefined;
}

/** QueryIndexersByGroupRequest is request type for the Query/IndexersByGroup RPC method. */
export interface QueryIndexersByGroupRequest {
  /**
   * group_id is the replication group ID (0, 1, 2, ...).
   * Groups are defined as every 3 indexers: Group 0 = indexers 1-3, Group 1 = indexers 4-6, etc.
   */
  groupId: number;
}

/** QueryIndexersByGroupResponse is response type for the Query/IndexersByGroup RPC method. */
export interface QueryIndexersByGroupResponse {
  /** indexers are all indexers in the specified group. */
  indexers: IndexerRange[];
  /** group_id is the replication group ID that was queried. */
  groupId: number;
  /** hash_prefix_start is the start of the prefix range assigned to this group. */
  hashPrefixStart: string;
  /** hash_prefix_end is the end of the prefix range assigned to this group. */
  hashPrefixEnd: string;
}

/** QueryIndexerExistsRequest is request type for the Query/IndexerExists RPC method. */
export interface QueryIndexerExistsRequest {
  /** indexer_id is the unique identifier of the indexer to check. */
  indexerId: string;
}

/** QueryIndexerExistsResponse is response type for the Query/IndexerExists RPC method. */
export interface QueryIndexerExistsResponse {
  /** exists indicates whether the indexer_id exists in the registry. */
  exists: boolean;
}

/** QueryStorageProviderRequest is request type for the Query/StorageProvider RPC method. */
export interface QueryStorageProviderRequest {
  /** provider_id is the unique identifier of the storage provider. */
  providerId: string;
}

/** QueryStorageProviderResponse is response type for the Query/StorageProvider RPC method. */
export interface QueryStorageProviderResponse {
  /** provider is the storage provider information, or null if not found. */
  provider:
    | StorageProvider
    | undefined;
  /** exists indicates whether the storage provider exists. */
  exists: boolean;
}

/** QueryGetRandomStorageProvidersRequest is request type for the Query/GetRandomStorageProviders RPC method. */
export interface QueryGetRandomStorageProvidersRequest {
  /**
   * count is the number of random storage providers to return (default: 3).
   * If there are fewer active providers than requested, all available providers will be returned.
   */
  count: number;
  /**
   * Optional: filter by minimum available capacity (bytes).
   * If specified, only providers with at least this much available capacity will be considered.
   */
  minAvailableCapacityBytes: number;
}

/** QueryGetRandomStorageProvidersResponse is response type for the Query/GetRandomStorageProviders RPC method. */
export interface QueryGetRandomStorageProvidersResponse {
  /**
   * providers is a list of randomly selected storage providers.
   * The list contains only actual providers (no null values).
   * Use returned_count to determine how many providers are in the list.
   * Example: if 3 are requested but only 1 exists, returns [provider1] with returned_count=1
   */
  providers: StorageProvider[];
  /** total_active_providers is the total number of active providers that were considered. */
  totalActiveProviders: number;
  /** returned_count is the actual number of providers returned (may be less than requested count). */
  returnedCount: number;
}

/** QueryFileDownloadRequest is request type for the Query/FileDownload RPC method. */
export interface QueryFileDownloadRequest {
  /** merkle_root is the Merkle root hash of the file to download. */
  merkleRoot: string;
  /** owner is the address of the file owner (for verification). */
  owner: string;
}

/** QueryFileDownloadResponse is response type for the Query/FileDownload RPC method. */
export interface QueryFileDownloadResponse {
  /** file is the file metadata retrieved from the indexer. */
  file:
    | FileMetadata
    | undefined;
  /** selected_indexer_id is the ID of the indexer that was queried. */
  selectedIndexerId: string;
  /** selected_indexer_address is the address of the indexer that was queried. */
  selectedIndexerAddress: string;
  /**
   * storage_providers is a list of storage providers that store this file.
   * This information comes from the indexer.
   */
  storageProviders: StorageProvider[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryAccountStorageRequest(): QueryAccountStorageRequest {
  return { address: "" };
}

export const QueryAccountStorageRequest: MessageFns<QueryAccountStorageRequest> = {
  encode(message: QueryAccountStorageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountStorageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountStorageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountStorageRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAccountStorageRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountStorageRequest>, I>>(base?: I): QueryAccountStorageRequest {
    return QueryAccountStorageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountStorageRequest>, I>>(object: I): QueryAccountStorageRequest {
    const message = createBaseQueryAccountStorageRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseSubscriptionInfo(): SubscriptionInfo {
  return {
    id: "",
    storageBytes: 0,
    startTime: 0,
    endTime: 0,
    durationSeconds: 0,
    remainingSeconds: 0,
    isActive: false,
  };
}

export const SubscriptionInfo: MessageFns<SubscriptionInfo> = {
  encode(message: SubscriptionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.storageBytes !== 0) {
      writer.uint32(16).int64(message.storageBytes);
    }
    if (message.startTime !== 0) {
      writer.uint32(24).int64(message.startTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(32).int64(message.endTime);
    }
    if (message.durationSeconds !== 0) {
      writer.uint32(40).int64(message.durationSeconds);
    }
    if (message.remainingSeconds !== 0) {
      writer.uint32(48).int64(message.remainingSeconds);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.storageBytes = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durationSeconds = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.remainingSeconds = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      storageBytes: isSet(object.storageBytes) ? globalThis.Number(object.storageBytes) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
      remainingSeconds: isSet(object.remainingSeconds) ? globalThis.Number(object.remainingSeconds) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: SubscriptionInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.storageBytes !== 0) {
      obj.storageBytes = Math.round(message.storageBytes);
    }
    if (message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.endTime !== 0) {
      obj.endTime = Math.round(message.endTime);
    }
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = Math.round(message.durationSeconds);
    }
    if (message.remainingSeconds !== 0) {
      obj.remainingSeconds = Math.round(message.remainingSeconds);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionInfo>, I>>(base?: I): SubscriptionInfo {
    return SubscriptionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionInfo>, I>>(object: I): SubscriptionInfo {
    const message = createBaseSubscriptionInfo();
    message.id = object.id ?? "";
    message.storageBytes = object.storageBytes ?? 0;
    message.startTime = object.startTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.durationSeconds = object.durationSeconds ?? 0;
    message.remainingSeconds = object.remainingSeconds ?? 0;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseQueryAccountStorageResponse(): QueryAccountStorageResponse {
  return { address: "", subscription: undefined };
}

export const QueryAccountStorageResponse: MessageFns<QueryAccountStorageResponse> = {
  encode(message: QueryAccountStorageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.subscription !== undefined) {
      SubscriptionInfo.encode(message.subscription, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountStorageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountStorageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscription = SubscriptionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountStorageResponse {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      subscription: isSet(object.subscription) ? SubscriptionInfo.fromJSON(object.subscription) : undefined,
    };
  },

  toJSON(message: QueryAccountStorageResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.subscription !== undefined) {
      obj.subscription = SubscriptionInfo.toJSON(message.subscription);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountStorageResponse>, I>>(base?: I): QueryAccountStorageResponse {
    return QueryAccountStorageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountStorageResponse>, I>>(object: I): QueryAccountStorageResponse {
    const message = createBaseQueryAccountStorageResponse();
    message.address = object.address ?? "";
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? SubscriptionInfo.fromPartial(object.subscription)
      : undefined;
    return message;
  },
};

function createBaseQueryAccountKeyRequest(): QueryAccountKeyRequest {
  return { address: "" };
}

export const QueryAccountKeyRequest: MessageFns<QueryAccountKeyRequest> = {
  encode(message: QueryAccountKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountKeyRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryAccountKeyRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountKeyRequest>, I>>(base?: I): QueryAccountKeyRequest {
    return QueryAccountKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountKeyRequest>, I>>(object: I): QueryAccountKeyRequest {
    const message = createBaseQueryAccountKeyRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryAccountKeyResponse(): QueryAccountKeyResponse {
  return { encryptedAccountKey: "" };
}

export const QueryAccountKeyResponse: MessageFns<QueryAccountKeyResponse> = {
  encode(message: QueryAccountKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encryptedAccountKey !== "") {
      writer.uint32(10).string(message.encryptedAccountKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encryptedAccountKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountKeyResponse {
    return {
      encryptedAccountKey: isSet(object.encryptedAccountKey) ? globalThis.String(object.encryptedAccountKey) : "",
    };
  },

  toJSON(message: QueryAccountKeyResponse): unknown {
    const obj: any = {};
    if (message.encryptedAccountKey !== "") {
      obj.encryptedAccountKey = message.encryptedAccountKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountKeyResponse>, I>>(base?: I): QueryAccountKeyResponse {
    return QueryAccountKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountKeyResponse>, I>>(object: I): QueryAccountKeyResponse {
    const message = createBaseQueryAccountKeyResponse();
    message.encryptedAccountKey = object.encryptedAccountKey ?? "";
    return message;
  },
};

function createBaseQueryFileRequest(): QueryFileRequest {
  return { merkleRoot: "" };
}

export const QueryFileRequest: MessageFns<QueryFileRequest> = {
  encode(message: QueryFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.merkleRoot !== "") {
      writer.uint32(10).string(message.merkleRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFileRequest {
    return { merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "" };
  },

  toJSON(message: QueryFileRequest): unknown {
    const obj: any = {};
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFileRequest>, I>>(base?: I): QueryFileRequest {
    return QueryFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFileRequest>, I>>(object: I): QueryFileRequest {
    const message = createBaseQueryFileRequest();
    message.merkleRoot = object.merkleRoot ?? "";
    return message;
  },
};

function createBaseQueryFileResponse(): QueryFileResponse {
  return { file: undefined };
}

export const QueryFileResponse: MessageFns<QueryFileResponse> = {
  encode(message: QueryFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== undefined) {
      FileMetadata.encode(message.file, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.file = FileMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFileResponse {
    return { file: isSet(object.file) ? FileMetadata.fromJSON(object.file) : undefined };
  },

  toJSON(message: QueryFileResponse): unknown {
    const obj: any = {};
    if (message.file !== undefined) {
      obj.file = FileMetadata.toJSON(message.file);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFileResponse>, I>>(base?: I): QueryFileResponse {
    return QueryFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFileResponse>, I>>(object: I): QueryFileResponse {
    const message = createBaseQueryFileResponse();
    message.file = (object.file !== undefined && object.file !== null)
      ? FileMetadata.fromPartial(object.file)
      : undefined;
    return message;
  },
};

function createBaseQueryFilesByProviderRequest(): QueryFilesByProviderRequest {
  return { provider: "", pagination: undefined };
}

export const QueryFilesByProviderRequest: MessageFns<QueryFilesByProviderRequest> = {
  encode(message: QueryFilesByProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFilesByProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFilesByProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFilesByProviderRequest {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryFilesByProviderRequest): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFilesByProviderRequest>, I>>(base?: I): QueryFilesByProviderRequest {
    return QueryFilesByProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFilesByProviderRequest>, I>>(object: I): QueryFilesByProviderRequest {
    const message = createBaseQueryFilesByProviderRequest();
    message.provider = object.provider ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryFilesByProviderResponse(): QueryFilesByProviderResponse {
  return { files: [], pagination: undefined };
}

export const QueryFilesByProviderResponse: MessageFns<QueryFilesByProviderResponse> = {
  encode(message: QueryFilesByProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFilesByProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFilesByProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFilesByProviderResponse {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileMetadata.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryFilesByProviderResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileMetadata.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFilesByProviderResponse>, I>>(base?: I): QueryFilesByProviderResponse {
    return QueryFilesByProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFilesByProviderResponse>, I>>(object: I): QueryFilesByProviderResponse {
    const message = createBaseQueryFilesByProviderResponse();
    message.files = object.files?.map((e) => FileMetadata.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIndexerRangeRequest(): QueryIndexerRangeRequest {
  return { indexerId: "" };
}

export const QueryIndexerRangeRequest: MessageFns<QueryIndexerRangeRequest> = {
  encode(message: QueryIndexerRangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexerId !== "") {
      writer.uint32(10).string(message.indexerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerRangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerRangeRequest {
    return { indexerId: isSet(object.indexerId) ? globalThis.String(object.indexerId) : "" };
  },

  toJSON(message: QueryIndexerRangeRequest): unknown {
    const obj: any = {};
    if (message.indexerId !== "") {
      obj.indexerId = message.indexerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerRangeRequest>, I>>(base?: I): QueryIndexerRangeRequest {
    return QueryIndexerRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerRangeRequest>, I>>(object: I): QueryIndexerRangeRequest {
    const message = createBaseQueryIndexerRangeRequest();
    message.indexerId = object.indexerId ?? "";
    return message;
  },
};

function createBaseQueryIndexerRangeResponse(): QueryIndexerRangeResponse {
  return { range: undefined };
}

export const QueryIndexerRangeResponse: MessageFns<QueryIndexerRangeResponse> = {
  encode(message: QueryIndexerRangeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      IndexerRange.encode(message.range, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerRangeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerRangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = IndexerRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerRangeResponse {
    return { range: isSet(object.range) ? IndexerRange.fromJSON(object.range) : undefined };
  },

  toJSON(message: QueryIndexerRangeResponse): unknown {
    const obj: any = {};
    if (message.range !== undefined) {
      obj.range = IndexerRange.toJSON(message.range);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerRangeResponse>, I>>(base?: I): QueryIndexerRangeResponse {
    return QueryIndexerRangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerRangeResponse>, I>>(object: I): QueryIndexerRangeResponse {
    const message = createBaseQueryIndexerRangeResponse();
    message.range = (object.range !== undefined && object.range !== null)
      ? IndexerRange.fromPartial(object.range)
      : undefined;
    return message;
  },
};

function createBaseQueryIndexerRangesRequest(): QueryIndexerRangesRequest {
  return { pagination: undefined };
}

export const QueryIndexerRangesRequest: MessageFns<QueryIndexerRangesRequest> = {
  encode(message: QueryIndexerRangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerRangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerRangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerRangesRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryIndexerRangesRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerRangesRequest>, I>>(base?: I): QueryIndexerRangesRequest {
    return QueryIndexerRangesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerRangesRequest>, I>>(object: I): QueryIndexerRangesRequest {
    const message = createBaseQueryIndexerRangesRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIndexerRangesResponse(): QueryIndexerRangesResponse {
  return { ranges: [], pagination: undefined };
}

export const QueryIndexerRangesResponse: MessageFns<QueryIndexerRangesResponse> = {
  encode(message: QueryIndexerRangesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ranges) {
      IndexerRange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerRangesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerRangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ranges.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerRangesResponse {
    return {
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => IndexerRange.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryIndexerRangesResponse): unknown {
    const obj: any = {};
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => IndexerRange.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerRangesResponse>, I>>(base?: I): QueryIndexerRangesResponse {
    return QueryIndexerRangesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerRangesResponse>, I>>(object: I): QueryIndexerRangesResponse {
    const message = createBaseQueryIndexerRangesResponse();
    message.ranges = object.ranges?.map((e) => IndexerRange.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryActiveIndexersRequest(): QueryActiveIndexersRequest {
  return { pagination: undefined };
}

export const QueryActiveIndexersRequest: MessageFns<QueryActiveIndexersRequest> = {
  encode(message: QueryActiveIndexersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveIndexersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveIndexersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryActiveIndexersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryActiveIndexersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryActiveIndexersRequest>, I>>(base?: I): QueryActiveIndexersRequest {
    return QueryActiveIndexersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryActiveIndexersRequest>, I>>(object: I): QueryActiveIndexersRequest {
    const message = createBaseQueryActiveIndexersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryActiveIndexersResponse(): QueryActiveIndexersResponse {
  return { indexers: [], totalCount: 0, pagination: undefined };
}

export const QueryActiveIndexersResponse: MessageFns<QueryActiveIndexersResponse> = {
  encode(message: QueryActiveIndexersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexers) {
      IndexerRange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int64(message.totalCount);
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveIndexersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveIndexersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexers.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryActiveIndexersResponse {
    return {
      indexers: globalThis.Array.isArray(object?.indexers)
        ? object.indexers.map((e: any) => IndexerRange.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryActiveIndexersResponse): unknown {
    const obj: any = {};
    if (message.indexers?.length) {
      obj.indexers = message.indexers.map((e) => IndexerRange.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryActiveIndexersResponse>, I>>(base?: I): QueryActiveIndexersResponse {
    return QueryActiveIndexersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryActiveIndexersResponse>, I>>(object: I): QueryActiveIndexersResponse {
    const message = createBaseQueryActiveIndexersResponse();
    message.indexers = object.indexers?.map((e) => IndexerRange.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIndexersForFileRequest(): QueryIndexersForFileRequest {
  return { merkleRoot: "" };
}

export const QueryIndexersForFileRequest: MessageFns<QueryIndexersForFileRequest> = {
  encode(message: QueryIndexersForFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.merkleRoot !== "") {
      writer.uint32(10).string(message.merkleRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexersForFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexersForFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexersForFileRequest {
    return { merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "" };
  },

  toJSON(message: QueryIndexersForFileRequest): unknown {
    const obj: any = {};
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexersForFileRequest>, I>>(base?: I): QueryIndexersForFileRequest {
    return QueryIndexersForFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexersForFileRequest>, I>>(object: I): QueryIndexersForFileRequest {
    const message = createBaseQueryIndexersForFileRequest();
    message.merkleRoot = object.merkleRoot ?? "";
    return message;
  },
};

function createBaseQueryIndexersForFileResponse(): QueryIndexersForFileResponse {
  return { indexers: [] };
}

export const QueryIndexersForFileResponse: MessageFns<QueryIndexersForFileResponse> = {
  encode(message: QueryIndexersForFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexers) {
      IndexerRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexersForFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexersForFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexers.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexersForFileResponse {
    return {
      indexers: globalThis.Array.isArray(object?.indexers)
        ? object.indexers.map((e: any) => IndexerRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryIndexersForFileResponse): unknown {
    const obj: any = {};
    if (message.indexers?.length) {
      obj.indexers = message.indexers.map((e) => IndexerRange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexersForFileResponse>, I>>(base?: I): QueryIndexersForFileResponse {
    return QueryIndexersForFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexersForFileResponse>, I>>(object: I): QueryIndexersForFileResponse {
    const message = createBaseQueryIndexersForFileResponse();
    message.indexers = object.indexers?.map((e) => IndexerRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPrefixLoadRequest(): QueryPrefixLoadRequest {
  return { prefix: "", depth: 0 };
}

export const QueryPrefixLoadRequest: MessageFns<QueryPrefixLoadRequest> = {
  encode(message: QueryPrefixLoadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefix !== "") {
      writer.uint32(10).string(message.prefix);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPrefixLoadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPrefixLoadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPrefixLoadRequest {
    return {
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
    };
  },

  toJSON(message: QueryPrefixLoadRequest): unknown {
    const obj: any = {};
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPrefixLoadRequest>, I>>(base?: I): QueryPrefixLoadRequest {
    return QueryPrefixLoadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPrefixLoadRequest>, I>>(object: I): QueryPrefixLoadRequest {
    const message = createBaseQueryPrefixLoadRequest();
    message.prefix = object.prefix ?? "";
    message.depth = object.depth ?? 0;
    return message;
  },
};

function createBaseQueryPrefixLoadResponse(): QueryPrefixLoadResponse {
  return { load: undefined };
}

export const QueryPrefixLoadResponse: MessageFns<QueryPrefixLoadResponse> = {
  encode(message: QueryPrefixLoadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.load !== undefined) {
      PrefixLoad.encode(message.load, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPrefixLoadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPrefixLoadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.load = PrefixLoad.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPrefixLoadResponse {
    return { load: isSet(object.load) ? PrefixLoad.fromJSON(object.load) : undefined };
  },

  toJSON(message: QueryPrefixLoadResponse): unknown {
    const obj: any = {};
    if (message.load !== undefined) {
      obj.load = PrefixLoad.toJSON(message.load);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPrefixLoadResponse>, I>>(base?: I): QueryPrefixLoadResponse {
    return QueryPrefixLoadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPrefixLoadResponse>, I>>(object: I): QueryPrefixLoadResponse {
    const message = createBaseQueryPrefixLoadResponse();
    message.load = (object.load !== undefined && object.load !== null)
      ? PrefixLoad.fromPartial(object.load)
      : undefined;
    return message;
  },
};

function createBaseQueryPrefixLoadsRequest(): QueryPrefixLoadsRequest {
  return { pagination: undefined };
}

export const QueryPrefixLoadsRequest: MessageFns<QueryPrefixLoadsRequest> = {
  encode(message: QueryPrefixLoadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPrefixLoadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPrefixLoadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPrefixLoadsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryPrefixLoadsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPrefixLoadsRequest>, I>>(base?: I): QueryPrefixLoadsRequest {
    return QueryPrefixLoadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPrefixLoadsRequest>, I>>(object: I): QueryPrefixLoadsRequest {
    const message = createBaseQueryPrefixLoadsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPrefixLoadsResponse(): QueryPrefixLoadsResponse {
  return { loads: [], pagination: undefined };
}

export const QueryPrefixLoadsResponse: MessageFns<QueryPrefixLoadsResponse> = {
  encode(message: QueryPrefixLoadsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.loads) {
      PrefixLoad.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPrefixLoadsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPrefixLoadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loads.push(PrefixLoad.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPrefixLoadsResponse {
    return {
      loads: globalThis.Array.isArray(object?.loads) ? object.loads.map((e: any) => PrefixLoad.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPrefixLoadsResponse): unknown {
    const obj: any = {};
    if (message.loads?.length) {
      obj.loads = message.loads.map((e) => PrefixLoad.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPrefixLoadsResponse>, I>>(base?: I): QueryPrefixLoadsResponse {
    return QueryPrefixLoadsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPrefixLoadsResponse>, I>>(object: I): QueryPrefixLoadsResponse {
    const message = createBaseQueryPrefixLoadsResponse();
    message.loads = object.loads?.map((e) => PrefixLoad.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryIndexersByGroupRequest(): QueryIndexersByGroupRequest {
  return { groupId: 0 };
}

export const QueryIndexersByGroupRequest: MessageFns<QueryIndexersByGroupRequest> = {
  encode(message: QueryIndexersByGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0) {
      writer.uint32(8).int64(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexersByGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexersByGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexersByGroupRequest {
    return { groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0 };
  },

  toJSON(message: QueryIndexersByGroupRequest): unknown {
    const obj: any = {};
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexersByGroupRequest>, I>>(base?: I): QueryIndexersByGroupRequest {
    return QueryIndexersByGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexersByGroupRequest>, I>>(object: I): QueryIndexersByGroupRequest {
    const message = createBaseQueryIndexersByGroupRequest();
    message.groupId = object.groupId ?? 0;
    return message;
  },
};

function createBaseQueryIndexersByGroupResponse(): QueryIndexersByGroupResponse {
  return { indexers: [], groupId: 0, hashPrefixStart: "", hashPrefixEnd: "" };
}

export const QueryIndexersByGroupResponse: MessageFns<QueryIndexersByGroupResponse> = {
  encode(message: QueryIndexersByGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexers) {
      IndexerRange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.groupId !== 0) {
      writer.uint32(16).int64(message.groupId);
    }
    if (message.hashPrefixStart !== "") {
      writer.uint32(26).string(message.hashPrefixStart);
    }
    if (message.hashPrefixEnd !== "") {
      writer.uint32(34).string(message.hashPrefixEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexersByGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexersByGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexers.push(IndexerRange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hashPrefixStart = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashPrefixEnd = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexersByGroupResponse {
    return {
      indexers: globalThis.Array.isArray(object?.indexers)
        ? object.indexers.map((e: any) => IndexerRange.fromJSON(e))
        : [],
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      hashPrefixStart: isSet(object.hashPrefixStart) ? globalThis.String(object.hashPrefixStart) : "",
      hashPrefixEnd: isSet(object.hashPrefixEnd) ? globalThis.String(object.hashPrefixEnd) : "",
    };
  },

  toJSON(message: QueryIndexersByGroupResponse): unknown {
    const obj: any = {};
    if (message.indexers?.length) {
      obj.indexers = message.indexers.map((e) => IndexerRange.toJSON(e));
    }
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.hashPrefixStart !== "") {
      obj.hashPrefixStart = message.hashPrefixStart;
    }
    if (message.hashPrefixEnd !== "") {
      obj.hashPrefixEnd = message.hashPrefixEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexersByGroupResponse>, I>>(base?: I): QueryIndexersByGroupResponse {
    return QueryIndexersByGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexersByGroupResponse>, I>>(object: I): QueryIndexersByGroupResponse {
    const message = createBaseQueryIndexersByGroupResponse();
    message.indexers = object.indexers?.map((e) => IndexerRange.fromPartial(e)) || [];
    message.groupId = object.groupId ?? 0;
    message.hashPrefixStart = object.hashPrefixStart ?? "";
    message.hashPrefixEnd = object.hashPrefixEnd ?? "";
    return message;
  },
};

function createBaseQueryIndexerExistsRequest(): QueryIndexerExistsRequest {
  return { indexerId: "" };
}

export const QueryIndexerExistsRequest: MessageFns<QueryIndexerExistsRequest> = {
  encode(message: QueryIndexerExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexerId !== "") {
      writer.uint32(10).string(message.indexerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerExistsRequest {
    return { indexerId: isSet(object.indexerId) ? globalThis.String(object.indexerId) : "" };
  },

  toJSON(message: QueryIndexerExistsRequest): unknown {
    const obj: any = {};
    if (message.indexerId !== "") {
      obj.indexerId = message.indexerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerExistsRequest>, I>>(base?: I): QueryIndexerExistsRequest {
    return QueryIndexerExistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerExistsRequest>, I>>(object: I): QueryIndexerExistsRequest {
    const message = createBaseQueryIndexerExistsRequest();
    message.indexerId = object.indexerId ?? "";
    return message;
  },
};

function createBaseQueryIndexerExistsResponse(): QueryIndexerExistsResponse {
  return { exists: false };
}

export const QueryIndexerExistsResponse: MessageFns<QueryIndexerExistsResponse> = {
  encode(message: QueryIndexerExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIndexerExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIndexerExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIndexerExistsResponse {
    return { exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false };
  },

  toJSON(message: QueryIndexerExistsResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryIndexerExistsResponse>, I>>(base?: I): QueryIndexerExistsResponse {
    return QueryIndexerExistsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryIndexerExistsResponse>, I>>(object: I): QueryIndexerExistsResponse {
    const message = createBaseQueryIndexerExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  },
};

function createBaseQueryStorageProviderRequest(): QueryStorageProviderRequest {
  return { providerId: "" };
}

export const QueryStorageProviderRequest: MessageFns<QueryStorageProviderRequest> = {
  encode(message: QueryStorageProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStorageProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStorageProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStorageProviderRequest {
    return { providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "" };
  },

  toJSON(message: QueryStorageProviderRequest): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStorageProviderRequest>, I>>(base?: I): QueryStorageProviderRequest {
    return QueryStorageProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStorageProviderRequest>, I>>(object: I): QueryStorageProviderRequest {
    const message = createBaseQueryStorageProviderRequest();
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseQueryStorageProviderResponse(): QueryStorageProviderResponse {
  return { provider: undefined, exists: false };
}

export const QueryStorageProviderResponse: MessageFns<QueryStorageProviderResponse> = {
  encode(message: QueryStorageProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== undefined) {
      StorageProvider.encode(message.provider, writer.uint32(10).fork()).join();
    }
    if (message.exists !== false) {
      writer.uint32(16).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStorageProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStorageProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = StorageProvider.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStorageProviderResponse {
    return {
      provider: isSet(object.provider) ? StorageProvider.fromJSON(object.provider) : undefined,
      exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
    };
  },

  toJSON(message: QueryStorageProviderResponse): unknown {
    const obj: any = {};
    if (message.provider !== undefined) {
      obj.provider = StorageProvider.toJSON(message.provider);
    }
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStorageProviderResponse>, I>>(base?: I): QueryStorageProviderResponse {
    return QueryStorageProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStorageProviderResponse>, I>>(object: I): QueryStorageProviderResponse {
    const message = createBaseQueryStorageProviderResponse();
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? StorageProvider.fromPartial(object.provider)
      : undefined;
    message.exists = object.exists ?? false;
    return message;
  },
};

function createBaseQueryGetRandomStorageProvidersRequest(): QueryGetRandomStorageProvidersRequest {
  return { count: 0, minAvailableCapacityBytes: 0 };
}

export const QueryGetRandomStorageProvidersRequest: MessageFns<QueryGetRandomStorageProvidersRequest> = {
  encode(message: QueryGetRandomStorageProvidersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    if (message.minAvailableCapacityBytes !== 0) {
      writer.uint32(16).int64(message.minAvailableCapacityBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetRandomStorageProvidersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetRandomStorageProvidersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minAvailableCapacityBytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetRandomStorageProvidersRequest {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minAvailableCapacityBytes: isSet(object.minAvailableCapacityBytes)
        ? globalThis.Number(object.minAvailableCapacityBytes)
        : 0,
    };
  },

  toJSON(message: QueryGetRandomStorageProvidersRequest): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minAvailableCapacityBytes !== 0) {
      obj.minAvailableCapacityBytes = Math.round(message.minAvailableCapacityBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetRandomStorageProvidersRequest>, I>>(
    base?: I,
  ): QueryGetRandomStorageProvidersRequest {
    return QueryGetRandomStorageProvidersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetRandomStorageProvidersRequest>, I>>(
    object: I,
  ): QueryGetRandomStorageProvidersRequest {
    const message = createBaseQueryGetRandomStorageProvidersRequest();
    message.count = object.count ?? 0;
    message.minAvailableCapacityBytes = object.minAvailableCapacityBytes ?? 0;
    return message;
  },
};

function createBaseQueryGetRandomStorageProvidersResponse(): QueryGetRandomStorageProvidersResponse {
  return { providers: [], totalActiveProviders: 0, returnedCount: 0 };
}

export const QueryGetRandomStorageProvidersResponse: MessageFns<QueryGetRandomStorageProvidersResponse> = {
  encode(message: QueryGetRandomStorageProvidersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.providers) {
      StorageProvider.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalActiveProviders !== 0) {
      writer.uint32(16).int64(message.totalActiveProviders);
    }
    if (message.returnedCount !== 0) {
      writer.uint32(24).int64(message.returnedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetRandomStorageProvidersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetRandomStorageProvidersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providers.push(StorageProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalActiveProviders = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.returnedCount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetRandomStorageProvidersResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => StorageProvider.fromJSON(e))
        : [],
      totalActiveProviders: isSet(object.totalActiveProviders) ? globalThis.Number(object.totalActiveProviders) : 0,
      returnedCount: isSet(object.returnedCount) ? globalThis.Number(object.returnedCount) : 0,
    };
  },

  toJSON(message: QueryGetRandomStorageProvidersResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => StorageProvider.toJSON(e));
    }
    if (message.totalActiveProviders !== 0) {
      obj.totalActiveProviders = Math.round(message.totalActiveProviders);
    }
    if (message.returnedCount !== 0) {
      obj.returnedCount = Math.round(message.returnedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetRandomStorageProvidersResponse>, I>>(
    base?: I,
  ): QueryGetRandomStorageProvidersResponse {
    return QueryGetRandomStorageProvidersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetRandomStorageProvidersResponse>, I>>(
    object: I,
  ): QueryGetRandomStorageProvidersResponse {
    const message = createBaseQueryGetRandomStorageProvidersResponse();
    message.providers = object.providers?.map((e) => StorageProvider.fromPartial(e)) || [];
    message.totalActiveProviders = object.totalActiveProviders ?? 0;
    message.returnedCount = object.returnedCount ?? 0;
    return message;
  },
};

function createBaseQueryFileDownloadRequest(): QueryFileDownloadRequest {
  return { merkleRoot: "", owner: "" };
}

export const QueryFileDownloadRequest: MessageFns<QueryFileDownloadRequest> = {
  encode(message: QueryFileDownloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.merkleRoot !== "") {
      writer.uint32(10).string(message.merkleRoot);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFileDownloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFileDownloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.merkleRoot = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFileDownloadRequest {
    return {
      merkleRoot: isSet(object.merkleRoot) ? globalThis.String(object.merkleRoot) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: QueryFileDownloadRequest): unknown {
    const obj: any = {};
    if (message.merkleRoot !== "") {
      obj.merkleRoot = message.merkleRoot;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFileDownloadRequest>, I>>(base?: I): QueryFileDownloadRequest {
    return QueryFileDownloadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFileDownloadRequest>, I>>(object: I): QueryFileDownloadRequest {
    const message = createBaseQueryFileDownloadRequest();
    message.merkleRoot = object.merkleRoot ?? "";
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseQueryFileDownloadResponse(): QueryFileDownloadResponse {
  return { file: undefined, selectedIndexerId: "", selectedIndexerAddress: "", storageProviders: [] };
}

export const QueryFileDownloadResponse: MessageFns<QueryFileDownloadResponse> = {
  encode(message: QueryFileDownloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== undefined) {
      FileMetadata.encode(message.file, writer.uint32(10).fork()).join();
    }
    if (message.selectedIndexerId !== "") {
      writer.uint32(18).string(message.selectedIndexerId);
    }
    if (message.selectedIndexerAddress !== "") {
      writer.uint32(26).string(message.selectedIndexerAddress);
    }
    for (const v of message.storageProviders) {
      StorageProvider.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryFileDownloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFileDownloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.file = FileMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selectedIndexerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selectedIndexerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storageProviders.push(StorageProvider.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFileDownloadResponse {
    return {
      file: isSet(object.file) ? FileMetadata.fromJSON(object.file) : undefined,
      selectedIndexerId: isSet(object.selectedIndexerId) ? globalThis.String(object.selectedIndexerId) : "",
      selectedIndexerAddress: isSet(object.selectedIndexerAddress)
        ? globalThis.String(object.selectedIndexerAddress)
        : "",
      storageProviders: globalThis.Array.isArray(object?.storageProviders)
        ? object.storageProviders.map((e: any) => StorageProvider.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryFileDownloadResponse): unknown {
    const obj: any = {};
    if (message.file !== undefined) {
      obj.file = FileMetadata.toJSON(message.file);
    }
    if (message.selectedIndexerId !== "") {
      obj.selectedIndexerId = message.selectedIndexerId;
    }
    if (message.selectedIndexerAddress !== "") {
      obj.selectedIndexerAddress = message.selectedIndexerAddress;
    }
    if (message.storageProviders?.length) {
      obj.storageProviders = message.storageProviders.map((e) => StorageProvider.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFileDownloadResponse>, I>>(base?: I): QueryFileDownloadResponse {
    return QueryFileDownloadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFileDownloadResponse>, I>>(object: I): QueryFileDownloadResponse {
    const message = createBaseQueryFileDownloadResponse();
    message.file = (object.file !== undefined && object.file !== null)
      ? FileMetadata.fromPartial(object.file)
      : undefined;
    message.selectedIndexerId = object.selectedIndexerId ?? "";
    message.selectedIndexerAddress = object.selectedIndexerAddress ?? "";
    message.storageProviders = object.storageProviders?.map((e) => StorageProvider.fromPartial(e)) || [];
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** AccountStorage queries storage information for an account. */
  AccountStorage(request: QueryAccountStorageRequest): Promise<QueryAccountStorageResponse>;
  /** AccountKey returns the encrypted symmetric key for an address. */
  AccountKey(request: QueryAccountKeyRequest): Promise<QueryAccountKeyResponse>;
  /** File queries file metadata by Merkle root hash. */
  File(request: QueryFileRequest): Promise<QueryFileResponse>;
  /** FilesByProvider queries all files stored by a provider. */
  FilesByProvider(request: QueryFilesByProviderRequest): Promise<QueryFilesByProviderResponse>;
  /** IndexerRange queries the hash prefix range assigned to a specific indexer. */
  IndexerRange(request: QueryIndexerRangeRequest): Promise<QueryIndexerRangeResponse>;
  /** IndexerRanges queries all indexer ranges (paginated). */
  IndexerRanges(request: QueryIndexerRangesRequest): Promise<QueryIndexerRangesResponse>;
  /** ActiveIndexers queries all currently active indexers. */
  ActiveIndexers(request: QueryActiveIndexersRequest): Promise<QueryActiveIndexersResponse>;
  /** IndexersForFile queries which indexers handle a specific file hash. */
  IndexersForFile(request: QueryIndexersForFileRequest): Promise<QueryIndexersForFileResponse>;
  /** PrefixLoad queries the load (file count) for a specific prefix. */
  PrefixLoad(request: QueryPrefixLoadRequest): Promise<QueryPrefixLoadResponse>;
  /** PrefixLoads queries all prefix loads (paginated, for load analysis). */
  PrefixLoads(request: QueryPrefixLoadsRequest): Promise<QueryPrefixLoadsResponse>;
  /** IndexersByGroup queries all indexers in a specific replication group. */
  IndexersByGroup(request: QueryIndexersByGroupRequest): Promise<QueryIndexersByGroupResponse>;
  /** IndexerExists checks if an indexer_id already exists. */
  IndexerExists(request: QueryIndexerExistsRequest): Promise<QueryIndexerExistsResponse>;
  /** StorageProvider queries a storage provider by provider_id to check if it exists. */
  StorageProvider(request: QueryStorageProviderRequest): Promise<QueryStorageProviderResponse>;
  /**
   * GetRandomStorageProviders queries random active storage providers.
   * Returns the requested number of providers (or fewer if not enough available).
   * Useful for load balancing and distributing file storage across providers.
   */
  GetRandomStorageProviders(
    request: QueryGetRandomStorageProvidersRequest,
  ): Promise<QueryGetRandomStorageProvidersResponse>;
  /**
   * FileDownload queries file information from an indexer for download.
   * It finds indexers that handle the file's merkle root prefix, randomly selects one,
   * and queries that indexer for the file metadata and storage provider information.
   */
  FileDownload(request: QueryFileDownloadRequest): Promise<QueryFileDownloadResponse>;
}

export const QueryServiceName = "osdblockchain.osdblockchain.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.AccountStorage = this.AccountStorage.bind(this);
    this.AccountKey = this.AccountKey.bind(this);
    this.File = this.File.bind(this);
    this.FilesByProvider = this.FilesByProvider.bind(this);
    this.IndexerRange = this.IndexerRange.bind(this);
    this.IndexerRanges = this.IndexerRanges.bind(this);
    this.ActiveIndexers = this.ActiveIndexers.bind(this);
    this.IndexersForFile = this.IndexersForFile.bind(this);
    this.PrefixLoad = this.PrefixLoad.bind(this);
    this.PrefixLoads = this.PrefixLoads.bind(this);
    this.IndexersByGroup = this.IndexersByGroup.bind(this);
    this.IndexerExists = this.IndexerExists.bind(this);
    this.StorageProvider = this.StorageProvider.bind(this);
    this.GetRandomStorageProviders = this.GetRandomStorageProviders.bind(this);
    this.FileDownload = this.FileDownload.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  AccountStorage(request: QueryAccountStorageRequest): Promise<QueryAccountStorageResponse> {
    const data = QueryAccountStorageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AccountStorage", data);
    return promise.then((data) => QueryAccountStorageResponse.decode(new BinaryReader(data)));
  }

  AccountKey(request: QueryAccountKeyRequest): Promise<QueryAccountKeyResponse> {
    const data = QueryAccountKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AccountKey", data);
    return promise.then((data) => QueryAccountKeyResponse.decode(new BinaryReader(data)));
  }

  File(request: QueryFileRequest): Promise<QueryFileResponse> {
    const data = QueryFileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "File", data);
    return promise.then((data) => QueryFileResponse.decode(new BinaryReader(data)));
  }

  FilesByProvider(request: QueryFilesByProviderRequest): Promise<QueryFilesByProviderResponse> {
    const data = QueryFilesByProviderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FilesByProvider", data);
    return promise.then((data) => QueryFilesByProviderResponse.decode(new BinaryReader(data)));
  }

  IndexerRange(request: QueryIndexerRangeRequest): Promise<QueryIndexerRangeResponse> {
    const data = QueryIndexerRangeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IndexerRange", data);
    return promise.then((data) => QueryIndexerRangeResponse.decode(new BinaryReader(data)));
  }

  IndexerRanges(request: QueryIndexerRangesRequest): Promise<QueryIndexerRangesResponse> {
    const data = QueryIndexerRangesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IndexerRanges", data);
    return promise.then((data) => QueryIndexerRangesResponse.decode(new BinaryReader(data)));
  }

  ActiveIndexers(request: QueryActiveIndexersRequest): Promise<QueryActiveIndexersResponse> {
    const data = QueryActiveIndexersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ActiveIndexers", data);
    return promise.then((data) => QueryActiveIndexersResponse.decode(new BinaryReader(data)));
  }

  IndexersForFile(request: QueryIndexersForFileRequest): Promise<QueryIndexersForFileResponse> {
    const data = QueryIndexersForFileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IndexersForFile", data);
    return promise.then((data) => QueryIndexersForFileResponse.decode(new BinaryReader(data)));
  }

  PrefixLoad(request: QueryPrefixLoadRequest): Promise<QueryPrefixLoadResponse> {
    const data = QueryPrefixLoadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PrefixLoad", data);
    return promise.then((data) => QueryPrefixLoadResponse.decode(new BinaryReader(data)));
  }

  PrefixLoads(request: QueryPrefixLoadsRequest): Promise<QueryPrefixLoadsResponse> {
    const data = QueryPrefixLoadsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PrefixLoads", data);
    return promise.then((data) => QueryPrefixLoadsResponse.decode(new BinaryReader(data)));
  }

  IndexersByGroup(request: QueryIndexersByGroupRequest): Promise<QueryIndexersByGroupResponse> {
    const data = QueryIndexersByGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IndexersByGroup", data);
    return promise.then((data) => QueryIndexersByGroupResponse.decode(new BinaryReader(data)));
  }

  IndexerExists(request: QueryIndexerExistsRequest): Promise<QueryIndexerExistsResponse> {
    const data = QueryIndexerExistsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IndexerExists", data);
    return promise.then((data) => QueryIndexerExistsResponse.decode(new BinaryReader(data)));
  }

  StorageProvider(request: QueryStorageProviderRequest): Promise<QueryStorageProviderResponse> {
    const data = QueryStorageProviderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StorageProvider", data);
    return promise.then((data) => QueryStorageProviderResponse.decode(new BinaryReader(data)));
  }

  GetRandomStorageProviders(
    request: QueryGetRandomStorageProvidersRequest,
  ): Promise<QueryGetRandomStorageProvidersResponse> {
    const data = QueryGetRandomStorageProvidersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRandomStorageProviders", data);
    return promise.then((data) => QueryGetRandomStorageProvidersResponse.decode(new BinaryReader(data)));
  }

  FileDownload(request: QueryFileDownloadRequest): Promise<QueryFileDownloadResponse> {
    const data = QueryFileDownloadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FileDownload", data);
    return promise.then((data) => QueryFileDownloadResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
